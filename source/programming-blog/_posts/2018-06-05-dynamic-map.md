---
layout: post
title: "DynamicMap"
description: "Add"
date: 2018-06-05 23:16:11 -0600
categories: programming-blog
---
I searched for hours for a library similar to AutoMapper but to map an object to a Type. In other words,
instead of `Map<TSource, TDestination>(obj)`, having something like this: `Map(typeof(TDestination), obj)`.
I even had an idea to use `Activator.CreateInstance()` to dynamically run the generic method call of
`Map<TSource, TDestination>(obj)` to substitute the static generic type but I realized AutoMapper also
needs a mapping profile. Writing that would be complicated ... really complicated.

I could not find anything, therefore, I tried to write my own (it works for simple types, but mapping
`IEnumerables` is kind of tricky). But later I found out that `AutoMapper` has an overload `Map` method
to map dynamic types. So, there is no reason to use my library but still (I am biased here ... I wrote
the code) but it is very simple and customizable. ([repo url with nuget package too][repo-url]).

The interesting part of this library is how easy it is to create a mapper profile in it to map type `A -> B`.
Any special mapper should implement `ISpecialMapper`, but there are a lot to implement, hence extend
`BaseDynamicMap` class too. So, implement any method that is needed to make your custom mapper to work
and just use `base` or `BaseDynamicMap` methods when you don't what to change default mapping behavior.

There is a `IsComplexType` in `PropertyInfoStructSource` model that is generated by `SourceToPropertyInfoStruct`
virtual methods. If the flag is set to `true`, they that specific property will be mapper recursively or will be
treated as a complex type.

Example:
{% highlight csharp %}
public class CustomClassSpecialMapper: BaseDynamicMap, ISpecialMapper
{
    // returns new instance of this mapper, needed due to the recursive nature of this library
    public new ISpecialMapper New() => new CustomClassSpecialMapper();

    // if true then this mapper will be used
    public bool MatchingMapper(Type destinationType, Type sourceType, object sourceObj)
    {
    return sourceType == typeof(CustomClass);
    }
    // order of custom mapper
    public int Order() => 4;
}
{% endhighlight %}

Existing custom mapping profiles:
1. `JObject`: `JSON.NET` object representation. Hence this library supports `JSON.NET` objects out of the box
2. `ExpandoObject`: It is essentially an `IDictionay<string, object>`, it can be very handy sometimes.
3. `IEnumerable`: any type of `List`

Notes:
1. `New` is needed to duplicate the instance of custom mapping profile
2. `Order()` is the order of your mapping profile. Because there are types like `ExpandoObject` that extend
`IDictionay<string, object>` and itself extends `IEnumerable` too. So make sure order is selected carefully.
3. `MatchingMapper` is used to check whether if custom profile should be used or not.

As always, I appreciate any feedback or contribution.

[repo-url]: https://github.com/amir734jj/DynamicMap